"""
KzBuilder â€” KzGrids Code Generator
Generates KzGrids.as ActionScript 2.0 source code from grid configurations.
"""

import shutil
import tempfile
from pathlib import Path
from datetime import datetime
from typing import Tuple

from Modules.as2_template import CORE_METHODS_TEMPLATE
from Modules.build_utils import compile_as2

MAX_TOTAL_SLOTS = 64

# ============================================================================
# CODE GENERATOR
# ============================================================================
class CodeGenerator:
    def __init__(self, grids, database, app_version="3.3.5"):
        # Filter out disabled grids
        self.grids = [g for g in grids if g.get('enabled', True)]
        self.database = database
        self.app_version = app_version

    def sanitize_id(self, grid_id):
        safe = ""
        for c in grid_id:
            if c.isalnum() or c == '_':
                safe += c
            else:
                safe += '_'
        if safe and safe[0].isdigit():
            safe = '_' + safe
        return safe or "Grid"

    def generate(self):
        lines = []
        lines.append(self._header())
        lines.append(self._class_start())
        lines.append(self._member_variables())
        lines.append(self._constructor())
        lines.append(self._init_config())
        lines.append(self._core_methods())
        lines.append(self._class_end())
        return '\n'.join(lines)

    def _header(self):
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M")
        total_slots = sum(g['rows'] * g['cols'] for g in self.grids)
        return f'''// ============================================================================
// KZGRIDS - Generated by KzBuilder v{self.app_version}
// Generated: {timestamp}
// Total slots: {total_slots} / {MAX_TOTAL_SLOTS}
// ============================================================================
'''

    def _class_start(self):
        return 'class KzGrids {\n'

    def _class_end(self):
        return '}\n'

    def _member_variables(self):
        return '''
    private var rootClip:MovieClip;
    private var m_Player:Object;
    private var m_Target:Object;
    private var config:Object;
    private var playerBuffs:Array;
    private var targetBuffs:Array;
    private var buffIndexCache:Object;
    private var grids:Array;
    private var timerInterval:Number;
    private var frameActive:Boolean;
    private var frameCount:Number;
    private var TCACHE:Object;
    private var previewMode:Boolean;
    private var previewArmed:Boolean;
    private var C_BUFF:Number;
    private var C_DEBUFF:Number;
    private var C_BG:Number;
    private var CFG:Object;
    private var WL:Object;
    private var ISDEB:Object;
    private var BUFFTYPE:Object;
    private var STACK_LEVEL:Object;

    // OPTIMIZATION: Alpha flash lookup table (100 pre-calculated values)
    private var AFLASH:Array;

    // OPTIMIZATION: Reusable arrays to reduce GC
    private var _tempBuffs:Array;
    private var _tempDebuffs:Array;
    private var _tempMisc:Array;

    // HELPER CLASSES: Preview and Console functionality (32KB bytecode limit workaround)
    private var preview:KzGridsPreview;
    private var console:KzGridsConsole;
    private var slot:KzGridsSlot;

    // Console pin state (persisted via config archive)
    private var consolePinned:Boolean;

    // Key listener reference for proper cleanup
    private var keyListener:Object;
'''

    def _constructor(self):
        return '''
    public function KzGrids(root:MovieClip) {
        rootClip = root;
        playerBuffs = new Array();
        targetBuffs = new Array();
        grids = new Array();
        buffIndexCache = {player: {}, target: {}};
        frameActive = false;
        frameCount = 0;
        previewMode = false;
        previewArmed = true;
        consolePinned = false;
        C_BUFF = 0x666666;
        C_DEBUFF = 0x8B0000;
        C_BG = 0x000000;
        TCACHE = {};
        var i:Number = 0;
        while (i <= 99) { TCACHE[i] = String(i); i++; }

        // OPTIMIZATION: Pre-calculate alpha flash values (100 entries)
        // Replaces Math.sin() calls every frame with array lookup
        AFLASH = new Array();
        var j:Number = 0;
        while (j < 100) {
            var phase:Number = (j / 100) * 6.28318;
            AFLASH[j] = 33 + (Math.sin(phase) + 1) * 33.5;
            j++;
        }

        // OPTIMIZATION: Reusable arrays to reduce garbage collection
        _tempBuffs = new Array();
        _tempDebuffs = new Array();
        _tempMisc = new Array();

        // HELPER CLASSES: Initialize preview, console, and slot managers
        preview = new KzGridsPreview(this, rootClip);
        console = new KzGridsConsole(this, rootClip);
        slot = new KzGridsSlot(this, rootClip);

        initConfig();
    }
'''

    def _init_config(self):
        lines = ['''
    private function initConfig():Void {
        CFG = {};
        CFG.grids = new Array();
        WL = {};
        ISDEB = {};
        BUFFTYPE = {};
        STACK_LEVEL = {};
        var i:Number;
''']

        all_buff_ids = set()
        for grid in self.grids:
            lines.append(self._generate_grid_config(grid))
            for bid in grid.get('whitelist', []):
                all_buff_ids.add(bid)
            for slot_ids in grid.get('slotAssignments', {}).values():
                for bid in slot_ids:
                    all_buff_ids.add(bid)

        if all_buff_ids:
            lines.append('\n        // Debuff, Type, and Stack Level lookup')
            for bid in sorted(all_buff_ids):
                is_deb = "true" if self.database.is_debuff(bid) else "false"
                buff_type = self.database.get_type(bid)
                lines.append(f'        ISDEB[{bid}] = {is_deb};')
                lines.append(f'        BUFFTYPE[{bid}] = "{buff_type}";')
                # Add stack level for stacking buffs
                stack_level = self.database.get_stack_level(bid)
                if stack_level is not None:
                    lines.append(f'        STACK_LEVEL[{bid}] = {stack_level};')

        lines.append('    }')
        return '\n'.join(lines)

    def _generate_grid_config(self, grid):
        gid = grid['id']
        vid = self.sanitize_id(gid)
        lines = []

        lines.append(f'''
        // {gid}
        var {vid}:Object = {{
            id: "{gid}",
            type: "{grid['type']}",
            rows: {grid['rows']},
            cols: {grid['cols']},
            iconSize: {grid['iconSize']},
            gap: {grid['gap']},
            x: {grid['x']},
            y: {grid['y']},
            slotMode: "{grid['slotMode']}",
            fillDir: "{grid['fillDirection']}",
            sortOrder: "{grid['sortOrder']}",
            layout: "{grid['layout']}",
            showTimers: {'true' if grid['showTimers'] else 'false'},
            timerFont: {grid.get('timerFontSize', 18)},
            timerFlashThreshold: {grid.get('timerFlashThreshold', 6)},
            timerYOffset: {grid.get('timerYOffset', 0)},
            enableFlashing: {'true' if grid.get('enableFlashing', True) else 'false'}''')

        if grid['slotMode'] == 'static':
            lines[-1] += ',\n            slots: {}\n        };'
            for slot_idx, buff_ids in grid.get('slotAssignments', {}).items():
                if buff_ids:
                    ids_str = ', '.join(str(bid) for bid in buff_ids)
                    lines.append(f'        {vid}.slots[{int(slot_idx)}] = [{ids_str}];')
        else:
            lines[-1] += '\n        };'

        lines.append(f'        CFG.grids.push({vid});')

        whitelist = grid.get('whitelist', [])
        if whitelist or grid['slotMode'] == 'dynamic':
            lines.append(f'\n        WL["{gid}"] = {{}};')
            if whitelist:
                ids_str = ', '.join(str(bid) for bid in whitelist)
                lines.append(f'        var {vid}_ids:Array = [{ids_str}];')
                lines.append(f'''        i = 0;
        while (i < {vid}_ids.length) {{
            WL["{gid}"][{vid}_ids[i]] = true;
            i++;
        }}''')

        if grid['slotMode'] == 'static':
            all_ids = set()
            for slot_ids in grid.get('slotAssignments', {}).values():
                all_ids.update(slot_ids)
            if all_ids:
                lines.append(f'\n        WL["{gid}"] = {{}};')
                for bid in sorted(all_ids):
                    lines.append(f'        WL["{gid}"][{bid}] = true;')

        return '\n'.join(lines)

    def _core_methods(self):
        return CORE_METHODS_TEMPLATE


# ============================================================================
# BUILD FUNCTION
# ============================================================================
def build_grids(
    grids: list,
    database,
    base_swf: str,
    stubs_path: str,
    output_swf: str,
    compiler_path: str,
    app_version: str = "3.3.5"
) -> Tuple[bool, str]:
    """
    Complete build process for KzGrids.swf.

    Args:
        grids: List of grid configuration dicts
        database: BuffDatabase instance
        base_swf: Path to assets/kzgrids/base.swf
        stubs_path: Path to assets/kzgrids/stubs/
        output_swf: Path to write final KzGrids.swf
        compiler_path: Path to mtasc.exe
        app_version: Version string for header comment

    Returns:
        (success: bool, message: str)
    """
    base_swf = Path(base_swf)
    stubs_path = Path(stubs_path)
    output_swf = Path(output_swf)
    compiler_path = Path(compiler_path)

    if not base_swf.exists():
        return False, f"KzGrids base.swf not found:\n{base_swf}"
    if not compiler_path.exists():
        return False, f"MTASC compiler not found:\n{compiler_path}"

    temp_dir = None
    try:
        # Step 1: Generate AS2 code
        generator = CodeGenerator(grids, database, app_version)
        code = generator.generate()

        # Step 2: Write to temp .as file
        temp_dir = tempfile.mkdtemp(prefix="kzgrids_")
        temp_as = Path(temp_dir) / "KzGrids.as"
        with open(temp_as, 'w', encoding='utf-8') as f:
            f.write(code)

        # Step 3: Copy base.swf to temp
        output_swf.parent.mkdir(parents=True, exist_ok=True)
        temp_swf = Path(temp_dir) / "KzGrids.swf"
        shutil.copy2(base_swf, temp_swf)

        # Step 4: Compile
        common_stubs = base_swf.parent.parent / "common_stubs"
        ok, err = compile_as2(compiler_path, [stubs_path, common_stubs], temp_swf, temp_as, temp_dir)
        if not ok:
            return False, f"MTASC compilation failed:\n{err}"

        # Step 5: Copy to game directory
        shutil.copy2(temp_swf, output_swf)

        output_size = output_swf.stat().st_size
        return True, f"KzGrids.swf built successfully ({output_size:,} bytes)"

    except Exception as e:
        return False, f"Build error: {str(e)}"
    finally:
        if temp_dir:
            try:
                shutil.rmtree(temp_dir)
            except Exception:
                pass
