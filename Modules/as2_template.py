"""
AS2 Core Methods Template for KzBuilder v3.3.4 - OPTIMIZED
This file contains the ActionScript 2.0 runtime code that gets compiled into the SWF.

OPTIMIZATIONS APPLIED:
- Pre-drawn slot symbols (BuffSlot/DebuffSlot/MiscSlot from Flash CS6)
- Grid visibility culling (skip hidden/empty grids)
- Math caching (alpha flash lookup table - 100 pre-calculated values)
- GC reduction (reusable arrays instead of new Array())
- Smart expiry checking (early exit when queue empty)
- Per-grid flashing control with configurable threshold

FLASH CS6 REQUIREMENTS:
- BuffSlot symbol: Linkage "BuffSlot", contains m_icon MovieClip at (0,0)
- DebuffSlot symbol: Linkage "DebuffSlot", contains m_icon MovieClip at (0,0)
- MiscSlot symbol: Linkage "MiscSlot", contains m_icon MovieClip at (0,0) with golden border
- All symbols should be 64x64 native size, will be scaled at runtime

v2.6.0 CHANGES:
- Stack counter display at top-right corner for stacking buffs
- Database v2 format support with STACK_LEVEL lookup
- Type-based slot selection (buff/debuff/misc)

v2.5.1 CHANGES:
- Configurable timer flash threshold (4-11 seconds, default 6)
- Timer Y-offset adjustment for precise positioning with different fonts
- Both timer text color and icon flash use the threshold setting
- Preview mode overlays: Grid name and coordinates now inside overlay, centered
- Vertical bar detection: Text rotates 90Â° for cols=1 layouts to fit inside

REFACTORING (32KB Bytecode Limit):
- Split into 3 classes to stay under MTASC 32KB per-class limit
- KzGrids.as (main) - Core buff tracking and grid management
- KzGridsPreview.as - Preview mode, overlays, dragging
- KzGridsConsole.as - Buff ID discovery console
"""

CORE_METHODS_TEMPLATE = '''
    private function createAllGrids():Void {
        var i:Number = 0;
        while (i < CFG.grids.length) {
            var g:Object = createGrid(CFG.grids[i], i);
            if (g != null) grids.push(g);
            i++;
        }
    }
    
    private function createGrid(cfg:Object, idx:Number):Object {
        var mc:MovieClip = rootClip.createEmptyMovieClip("g_" + idx, rootClip.getNextHighestDepth());
        if (mc == null) return null;
        var total:Number = cfg.rows * cfg.cols;
        var slots:Array = new Array();
        var loaders:Array = new Array();
        var loading:Array = new Array();
        var s:Number = 0;
        while (s < total) {
            slots.push(createSlot(mc, s, cfg));
            loaders[s] = new MovieClipLoader();
            loaders[s].addListener(this);
            loading[s] = false;
            s++;
        }
        mc._x = cfg.x;
        mc._y = cfg.y;
        mc._visible = false;
        var obj:Object = {
            mc: mc, cfg: cfg, slots: slots, loaders: loaders,
            loading: loading, display: new Array(), dirty: true
        };
        createCallbacks(obj, idx);
        return obj;
    }
    
    private function createSlot(p:MovieClip, idx:Number, cfg:Object):MovieClip {
        // PRE-DRAWN: Use BuffSlot symbol from library (default, will swap if needed)
        var s:MovieClip = p.attachMovie("BuffSlot", "s" + idx, p.getNextHighestDepth());
        if (s == null) {
            s = p.createEmptyMovieClip("s" + idx, p.getNextHighestDepth());
            s.createEmptyMovieClip("m_icon", s.getNextHighestDepth());
        }
        var sz:Number = cfg.iconSize;
        var scale:Number = (sz / 64) * 100;
        s._xscale = s._yscale = scale;
        if (cfg.showTimers) slot.createTimerTF(s, cfg.timerFont, cfg.timerYOffset);
        slot.createStackTF(s);
        posSlot(s, idx, cfg);
        s._visible = false;
        s._idx = idx;
        s._sz = sz;
        s._fs = cfg.timerFont;
        s._lastIco = null;
        s._lastSec = null;
        s._buff = null;
        s._slotType = null;
        return s;
    }
    
    private function posSlot(s:MovieClip, idx:Number, cfg:Object):Void {
        var step:Number = cfg.iconSize + cfg.gap;
        var r:Number, c:Number;
        if (cfg.rows == 1) {
            r = 0;
            c = (cfg.fillDir == "RL") ? (cfg.cols - 1 - idx) : idx;
        } else if (cfg.cols == 1) {
            c = 0;
            r = (cfg.fillDir == "BT") ? (cfg.rows - 1 - idx) : idx;
        } else {
            var br:Number = Math.floor(idx / cfg.cols);
            var bc:Number = idx % cfg.cols;
            if (cfg.fillDir == "TL-BR") { r = br; c = bc; }
            else if (cfg.fillDir == "TR-BL") { r = br; c = cfg.cols - 1 - bc; }
            else if (cfg.fillDir == "BL-TR") { r = cfg.rows - 1 - br; c = bc; }
            else if (cfg.fillDir == "BR-TL") { r = cfg.rows - 1 - br; c = cfg.cols - 1 - bc; }
            else { r = br; c = bc; }
        }
        s._x = c * step;
        s._y = r * step;
    }
    
    private function createCallbacks(obj:Object, gIdx:Number):Void {
        var total:Number = obj.cfg.rows * obj.cfg.cols;
        var i:Number = 0;
        while (i < total) { obj["cb" + i] = createCB(obj, i); i++; }
    }
    
    private function createCB(obj:Object, si:Number):Function {
        var self:KzGrids = this;
        return function(url:String, ok:Boolean):Void { self.onIconLoad(obj, si, url, ok); };
    }
    
    private function onIconLoad(obj:Object, si:Number, url:String, ok:Boolean):Void {
        if (obj == null || obj.loading == null) return;
        obj.loading[si] = false;
        if (ok && url != null && url.length > 0) {
            var s:MovieClip = obj.slots[si];
            if (s != null && s._visible && s.m_icon != null && s._buff != null) {
                try { obj.loaders[si].loadClip(url, s.m_icon); } catch (e:Object) {}
            }
        }
    }
    
    private function loadIcon(obj:Object, si:Number, entry:Object):Void {
        if (entry == null || entry.buff == null || entry.buff.m_Icon == null) return;
        var s:MovieClip = obj.slots[si];
        if (s == null || s.m_icon == null) return;
        var inst:Number;
        try { inst = entry.buff.m_Icon.GetInstance(); } catch (e:Object) { return; }
        if (inst == null || inst == undefined || inst == 0) return;
        if (s._lastIco == inst && s.m_icon._visible) return;
        obj.loading[si] = false;
        s._lastIco = inst;
        obj.loading[si] = true;
        s.m_icon._visible = false;
        try { s.m_icon.unloadMovie(); } catch (e:Object) {}
        try {
            com.Utils.ImageLoader.RequestRDBImage(new com.Utils.ID32(1010008, inst), obj, "cb" + si);
        } catch (e:Object) { obj.loading[si] = false; }
    }
    
    public function onLoadInit(mc:MovieClip):Void {
        if (mc == null) return;
        try {
            if (mc._parent == null || !mc._parent._visible) return;
            mc._xscale = mc._yscale = 100;
            // Standardize to 64x64 (native symbol size) then parent scaling handles final size
            var NATIVE_SIZE:Number = 64;
            var scale:Number = (NATIVE_SIZE * 100) / Math.max(mc._width, mc._height);
            mc._xscale = mc._yscale = scale;
            mc.cacheAsBitmap = true;
            mc._visible = true;
        } catch (e:Object) {
            if (mc != null) { mc._xscale = mc._yscale = 100; mc._visible = true; }
        }
    }
    
    private function isTracked(bid:Number, obj:Object):Boolean {
        var wl:Object = WL[obj.cfg.id];
        return (wl != null && wl[bid] == true);
    }
    
    private function mkEntry(buff:Object):Object {
        var bid:Number = Number(buff.m_BuffId);
        var exp:Number = 0;
        if (buff.m_RemainingTime > 0) exp = getTimer() + buff.m_RemainingTime;
        var btype:String = BUFFTYPE[bid];
        if (btype == null || btype == undefined) btype = (ISDEB[bid] == true) ? "debuff" : "buff";
        return { buff: buff, id: bid, exp: exp, isD: (ISDEB[bid] == true), type: btype, at: getTimer() };
    }
    
    private function addPBuff(buff:Object):Void {
        if (buff == null || buff.m_BuffId == null) return;
        var bid:Number = Number(buff.m_BuffId);
        var tracked:Boolean = false;
        var i:Number = 0;
        while (i < grids.length) {
            if (grids[i].cfg.type == "player" && isTracked(bid, grids[i])) { tracked = true; break; }
            i++;
        }
        if (!tracked) return;
        var entry:Object = mkEntry(buff);
        var cache:Object = buffIndexCache.player;
        var idx:Number = cache[bid];
        if (idx != undefined && idx < playerBuffs.length && playerBuffs[idx] != null && playerBuffs[idx].id == bid) {
            playerBuffs[idx] = entry;
        } else {
            cache[bid] = playerBuffs.length;
            playerBuffs.push(entry);
        }
        markDirty("player");
        startTimer();
    }
    
    private function remPBuff(bid:Number):Void {
        var cache:Object = buffIndexCache.player;
        var idx:Number = cache[bid];
        if (idx != undefined && idx < playerBuffs.length && playerBuffs[idx] != null && playerBuffs[idx].id == bid) {
            playerBuffs.splice(idx, 1);
            delete cache[bid];
            rebuildCache(cache, playerBuffs, idx);
            markDirty("player");
        }
    }
    
    private function addTBuff(buff:Object):Void {
        if (buff == null || buff.m_BuffId == null) return;
        var bid:Number = Number(buff.m_BuffId);
        var tracked:Boolean = false;
        var i:Number = 0;
        while (i < grids.length) {
            if (grids[i].cfg.type == "target" && isTracked(bid, grids[i])) { tracked = true; break; }
            i++;
        }
        if (!tracked) return;
        var entry:Object = mkEntry(buff);
        var cache:Object = buffIndexCache.target;
        var idx:Number = cache[bid];
        if (idx != undefined && idx < targetBuffs.length && targetBuffs[idx] != null && targetBuffs[idx].id == bid) {
            targetBuffs[idx] = entry;
        } else {
            cache[bid] = targetBuffs.length;
            targetBuffs.push(entry);
        }
        markDirty("target");
        startTimer();
    }
    
    private function remTBuff(bid:Number):Void {
        var cache:Object = buffIndexCache.target;
        var idx:Number = cache[bid];
        if (idx != undefined && idx < targetBuffs.length && targetBuffs[idx] != null && targetBuffs[idx].id == bid) {
            targetBuffs.splice(idx, 1);
            delete cache[bid];
            rebuildCache(cache, targetBuffs, idx);
            markDirty("target");
        }
    }
    
    private function rebuildCache(cache:Object, arr:Array, rem:Number):Void {
        for (var k:String in cache) { if (cache[k] > rem) cache[k]--; }
    }
    
    private function markDirty(t:String):Void {
        var i:Number = 0;
        while (i < grids.length) { if (grids[i].cfg.type == t) grids[i].dirty = true; i++; }
    }
    
    private function updateGrid(obj:Object):Void {
        if (!obj.dirty) return;
        obj.dirty = false;
        if (obj.cfg.slotMode == "static") updateStatic(obj);
        else updateDynamic(obj);
    }
    
    private function updateDynamic(obj:Object):Void {
        var src:Array = (obj.cfg.type == "player") ? playerBuffs : targetBuffs;

        // GC OPTIMIZATION: Reuse arrays instead of new Array()
        _tempBuffs.length = 0;
        _tempDebuffs.length = 0;
        _tempMisc.length = 0;

        var i:Number = 0;
        while (i < src.length) {
            var e:Object = src[i];
            if (e != null && isTracked(e.id, obj)) {
                if (e.type == "misc") _tempMisc.push(e);
                else if (e.isD) _tempDebuffs.push(e);
                else _tempBuffs.push(e);
            }
            i++;
        }
        var now:Number = getTimer();
        sortArr(_tempMisc, obj.cfg.sortOrder, now);
        sortArr(_tempBuffs, obj.cfg.sortOrder, now);
        sortArr(_tempDebuffs, obj.cfg.sortOrder, now);
        var disp:Array;
        // Misc always first, then buff/debuff order based on layout
        if (obj.cfg.layout == "buffFirst") disp = _tempMisc.concat(_tempBuffs).concat(_tempDebuffs);
        else if (obj.cfg.layout == "debuffFirst") disp = _tempMisc.concat(_tempDebuffs).concat(_tempBuffs);
        else { disp = _tempMisc.concat(_tempBuffs).concat(_tempDebuffs); sortArr(disp, obj.cfg.sortOrder, now); }
        var total:Number = obj.cfg.rows * obj.cfg.cols;
        i = 0;
        while (i < total) {
            if (i < disp.length) showSlot(obj, obj.slots[i], disp[i], i);
            else hideSlot(obj.slots[i]);
            i++;
        }
        obj.display = disp;
        if (!previewMode) obj.mc._visible = disp.length > 0;
    }
    
    private function updateStatic(obj:Object):Void {
        var src:Array = (obj.cfg.type == "player") ? playerBuffs : targetBuffs;
        var sa:Object = obj.cfg.slots;
        var total:Number = obj.cfg.rows * obj.cfg.cols;
        var disp:Array = new Array();
        var hasAny:Boolean = false;
        var i:Number = 0;
        while (i < total) {
            var s:MovieClip = obj.slots[i];
            var ids:Array = sa[i];
            if (ids == null || ids.length == 0) { hideSlot(s); disp[i] = null; i++; continue; }
            var active:Object = null;
            var latest:Number = -1;
            var j:Number = 0;
            while (j < src.length) {
                var e:Object = src[j];
                if (e != null) {
                    var k:Number = 0;
                    while (k < ids.length) {
                        if (e.id == ids[k] && e.at > latest) { latest = e.at; active = e; break; }
                        k++;
                    }
                }
                j++;
            }
            if (active != null) { showSlot(obj, s, active, i); disp[i] = active; hasAny = true; }
            else { hideSlot(s); disp[i] = null; }
            i++;
        }
        obj.display = disp;
        if (!previewMode) obj.mc._visible = hasAny;
    }
    
    private function sortArr(arr:Array, order:String, now:Number):Void {
        if (arr.length <= 1) return;
        if (order == "shortest") {
            arr.sort(function(a, b) {
                var ra:Number = (a.exp > 0) ? (a.exp - now) : 999999;
                var rb:Number = (b.exp > 0) ? (b.exp - now) : 999999;
                return ra - rb;
            });
        } else if (order == "longest") {
            arr.sort(function(a, b) {
                var ra:Number = (a.exp > 0) ? (a.exp - now) : 999999;
                var rb:Number = (b.exp > 0) ? (b.exp - now) : 999999;
                return rb - ra;
            });
        } else {
            arr.sort(function(a, b) { return a.at - b.at; });
        }
    }
    
    private function showSlot(obj:Object, s:MovieClip, e:Object, si:Number):Void {
        if (s == null || e == null) return;
        var slotType:String = "BuffSlot";
        if (e.type == "misc") slotType = "MiscSlot";
        else if (e.isD) slotType = "DebuffSlot";
        s = slot.swapType(obj, s, si, slotType);
        s._visible = true;
        s._buff = e;
        if (s.stk != null) {
            var stackLvl:Number = STACK_LEVEL[e.id];
            var stkTxt:String = (stackLvl != null && stackLvl != undefined) ? String(stackLvl) : "";
            s.stk.text = stkTxt;
            if (s.stkShadow != null) s.stkShadow.text = stkTxt;
        }
        loadIcon(obj, si, e);
    }
    
    private function hideSlot(s:MovieClip):Void {
        if (s == null) return;
        s._visible = false;
        s._buff = null;
        s._lastIco = null;
        s._lastSec = null;
        if (s.tmr != null) s.tmr.text = "";
        if (s.tmrShadow != null) s.tmrShadow.text = "";
        if (s.stk != null) s.stk.text = "";
        if (s.stkShadow != null) s.stkShadow.text = "";
        if (s.m_icon != null) { s.m_icon._visible = false; try { s.m_icon.unloadMovie(); } catch (e:Object) {} }
    }
    
    private function startTimer():Void {
        if (timerInterval == null || timerInterval == undefined) {
            var self:KzGrids = this;
            timerInterval = setInterval(function() { self.tick(); }, 100);
        }
        if (!frameActive) {
            frameActive = true;
            var self2:KzGrids = this;
            rootClip.onEnterFrame = function() { self2.frame(); };
        }
    }
    
    private function stopTimer():Void {
        if (timerInterval != null) { clearInterval(timerInterval); timerInterval = null; }
        frameActive = false;
        rootClip.onEnterFrame = null;
    }
    
    private function tick():Void {
        var now:Number = getTimer();

        // SMART EXPIRY: Early exit if no buffs
        if (playerBuffs.length > 0) checkExpiry(playerBuffs, buffIndexCache.player, now, "player");
        if (targetBuffs.length > 0) checkExpiry(targetBuffs, buffIndexCache.target, now, "target");

        var i:Number = 0;
        while (i < grids.length) { updateGrid(grids[i]); i++; }
        if (playerBuffs.length == 0 && targetBuffs.length == 0) stopTimer();
    }

    private function hideAllGrids():Void {
        var i:Number = 0;
        while (i < grids.length) {
            if (grids[i].mc != null) grids[i].mc._visible = false;
            i++;
        }
        playerBuffs = new Array();
        targetBuffs = new Array();
        buffIndexCache = {player: {}, target: {}};
    }
    
    private function checkExpiry(arr:Array, cache:Object, now:Number, t:String):Void {
        var i:Number = arr.length - 1;
        while (i >= 0) {
            var e:Object = arr[i];
            if (e != null && e.exp > 0 && e.exp <= now) {
                arr.splice(i, 1);
                delete cache[e.id];
                rebuildCache(cache, arr, i);
                markDirty(t);
            }
            i--;
        }
    }
    
    private function frame():Void {
        if (!frameActive) return;
        frameCount = (frameCount + 1) % 32768;
        if (frameCount % 3 != 0) return;
        animate();
    }
    
    private function animate():Void {
        var now:Number = getTimer();
        var i:Number = 0;
        while (i < grids.length) {
            var obj:Object = grids[i];
            
            // GRID VISIBILITY CULLING: Skip if grid not visible or empty
            if (!obj.mc._visible || obj.display.length == 0) {
                i++;
                continue;
            }
            
            var j:Number = 0;
            while (j < obj.slots.length) {
                var s:MovieClip = obj.slots[j];
                if (s != null && s._visible && s._buff != null) animSlot(obj, s, s._buff, j, now);
                j++;
            }
            i++;
        }
    }
    
    private function animSlot(obj:Object, s:MovieClip, e:Object, si:Number, now:Number):Void {
        var rem:Number = (e.exp > 0) ? (e.exp - now) : 0;
        if (rem < 0) rem = 0;
        var threshold:Number = obj.cfg.timerFlashThreshold * 1000;
        if (s.tmr != null) {
            var sec:Number = Math.floor(rem / 1000);
            if (s._lastSec != sec) {
                var txt:String = (rem > 0) ? ((TCACHE[sec] != null) ? TCACHE[sec] : String(sec)) : "";
                s.tmr.text = txt;
                if (s.tmrShadow != null) s.tmrShadow.text = txt;
                s._lastSec = sec;
            }
            s.tmr.textColor = (rem > 0 && rem <= threshold) ? 0xFF3333 : 0xFFFFFF;
        }
        if (s.m_icon != null && !s.m_icon._visible) loadIcon(obj, si, e);
        var tgt:MovieClip = (s.m_icon != null) ? s.m_icon : s;
        // PER-GRID FLASHING: Respect enableFlashing config and threshold
        if (obj.cfg.enableFlashing && rem > 0 && rem <= threshold) {
            // MATH CACHING: Use pre-calculated alpha lookup instead of Math.sin
            var flashIdx:Number = Math.floor((now % 1000) / 10);
            if (flashIdx > 99) flashIdx = 99;
            tgt._alpha = AFLASH[flashIdx];
        } else { tgt._alpha = 100; }
    }
    
    private function SlotAlive():Void {
        try {
            if (m_Player != null) disconnectP(m_Player);
            playerBuffs = new Array();
            buffIndexCache.player = {};
            m_Player = com.GameInterface.Game.Character.GetClientCharacter();
            if (m_Player != null) {
                connectP(m_Player);
                var tgt:Object = m_Player.GetOffensiveTarget();
                if (tgt != null && tgt.GetType() != _global.Enums.TypeID.e_Type_None) SlotTargetChanged(tgt);
            }
        } catch (e:Object) {
            var self:KzGrids = this;
            setTimeout(function() { self.SlotAlive(); }, 1000);
        }
    }
    
    private function connectP(ch:Object):Void {
        if (ch == null) return;
        try {
            ch.SignalBuffAdded.Connect(SlotPBuffAdd, this);
            ch.SignalBuffUpdated.Connect(SlotPBuffAdd, this);
            ch.SignalBuffRemoved.Connect(SlotPBuffRem, this);
            ch.SignalOffensiveTargetChanged.Connect(SlotTargetChanged, this);
        } catch (e:Object) {}
    }
    
    private function disconnectP(ch:Object):Void {
        if (ch == null) return;
        try {
            ch.SignalBuffAdded.Disconnect(SlotPBuffAdd, this);
            ch.SignalBuffUpdated.Disconnect(SlotPBuffAdd, this);
            ch.SignalBuffRemoved.Disconnect(SlotPBuffRem, this);
            ch.SignalOffensiveTargetChanged.Disconnect(SlotTargetChanged, this);
        } catch (e:Object) {}
    }
    
    private function SlotTargetChanged(tid:Object):Void {
        if (tid == null || tid.GetType() == _global.Enums.TypeID.e_Type_None) setTarget(null);
        else setTarget(com.GameInterface.Game.Character.GetCharacter(tid));
    }
    
    private function setTarget(ch:Object):Void {
        try {
            if (m_Target != null) disconnectT(m_Target);
            targetBuffs = new Array();
            buffIndexCache.target = {};
            m_Target = ch;
            if (m_Target != null) { connectT(m_Target); loadTBuffs(); }
            markDirty("target");
            var i:Number = 0;
            while (i < grids.length) { if (grids[i].cfg.type == "target") updateGrid(grids[i]); i++; }
        } catch (e:Object) { targetBuffs = new Array(); }
    }
    
    private function connectT(ch:Object):Void {
        if (ch == null) return;
        try {
            ch.SignalBuffAdded.Connect(SlotTBuffAdd, this);
            ch.SignalBuffUpdated.Connect(SlotTBuffAdd, this);
            ch.SignalBuffRemoved.Connect(SlotTBuffRem, this);
        } catch (e:Object) {}
    }
    
    private function disconnectT(ch:Object):Void {
        if (ch == null) return;
        try {
            ch.SignalBuffAdded.Disconnect(SlotTBuffAdd, this);
            ch.SignalBuffUpdated.Disconnect(SlotTBuffAdd, this);
            ch.SignalBuffRemoved.Disconnect(SlotTBuffRem, this);
        } catch (e:Object) {}
    }
    
    private function loadTBuffs():Void {
        if (m_Target == null || m_Target.m_BuffList == null) return;
        try { for (var k:String in m_Target.m_BuffList) { var buff:Object = m_Target.m_BuffList[k]; if (buff != null) addTBuff(buff); } } catch (e:Object) {}
    }
    
    private function SlotPBuffAdd(bid:Number):Void {
        if (m_Player != null && m_Player.m_BuffList != null && m_Player.m_BuffList[bid] != null) {
            var buff:Object = m_Player.m_BuffList[bid];
            addPBuff(buff);
            if (console.isActive() && buff.m_Name != null) console.logPlayer(buff.m_Name, bid);
        }
    }

    private function SlotTBuffAdd(bid:Number):Void {
        if (m_Target != null && m_Target.m_BuffList != null && m_Target.m_BuffList[bid] != null) {
            var buff:Object = m_Target.m_BuffList[bid];
            addTBuff(buff);
            if (console.isActive() && buff.m_Name != null) console.logTarget(buff.m_Name, bid);
        }
    }
    
    private function SlotPBuffRem(bid:Number):Void { remPBuff(bid); }
    private function SlotTBuffRem(bid:Number):Void { remTBuff(bid); }
    
    private function handleKeyDown():Void {
        if (Key.isDown(16) && Key.isDown(17) && Key.isDown(18)) {
            if (previewArmed) { previewArmed = false; if (!previewMode) enterPreview(); else exitPreview(); }
        }
    }
    
    private function handleKeyUp():Void {
        if (!(Key.isDown(16) && Key.isDown(17) && Key.isDown(18))) previewArmed = true;
    }
    
    private function enterPreview():Void {
        if (previewMode) return;
        previewMode = true;
        var i:Number = 0;
        while (i < grids.length) {
            var obj:Object = grids[i];
            obj.mc._visible = true;
            var j:Number = 0;
            while (j < obj.slots.length) { obj.slots[j]._visible = true; j++; }
            preview.createOverlay(obj);
            i++;
        }
        if (!console.isActive()) console.createConsole();
    }

    private function exitPreview():Void {
        if (!previewMode) return;
        previewMode = false;
        if (config) {
            var j:Number = 0;
            while (j < grids.length) {
                config.ReplaceEntry("g" + j + "_x", grids[j].mc._x);
                config.ReplaceEntry("g" + j + "_y", grids[j].mc._y);
                j++;
            }
            config.ReplaceEntry("console_pin", consolePinned ? 1 : 0);
            config.ReplaceEntry("log_p", console.logPlayerEnabled ? 1 : 0);
            config.ReplaceEntry("log_t", console.logTargetEnabled ? 1 : 0);
        }
        if (!consolePinned) console.removeConsole();
        var i:Number = 0;
        while (i < grids.length) { preview.removeOverlay(grids[i]); grids[i].dirty = true; updateGrid(grids[i]); i++; }
    }
    
    private function cleanup():Void {
        stopTimer();
        previewMode = false;
        if (keyListener != null) { Key.removeListener(keyListener); keyListener = null; }
        console.removeConsole();
        playerBuffs = new Array();
        targetBuffs = new Array();
        buffIndexCache = {player: {}, target: {}};
        var i:Number = 0;
        while (i < grids.length) {
            var obj:Object = grids[i];
            preview.removeOverlay(obj);
            var j:Number = 0;
            while (j < obj.loaders.length) { if (obj.loaders[j] != null) { obj.loaders[j].removeListener(this); obj.loaders[j] = null; } j++; }
            if (obj.mc != null) obj.mc.removeMovieClip();
            i++;
        }
        grids = new Array();
    }
    
    public function onLoad():Void {
        Stage.showMenu = false;
        // Clean up previous state if onLoad is called again (double-init protection)
        if (keyListener != null) Key.removeListener(keyListener);
        if (grids.length > 0) {
            var c:Number = 0;
            while (c < grids.length) { if (grids[c].mc != null) grids[c].mc.removeMovieClip(); c++; }
            grids = new Array();
        }
        var self:KzGrids = this;
        keyListener = {};
        keyListener.onKeyDown = function() { self.handleKeyDown(); };
        keyListener.onKeyUp = function() { self.handleKeyUp(); };
        Key.addListener(keyListener);
        createAllGrids();
        try {
            com.GameInterface.Game.CharacterBase.SignalClientCharacterAlive.Connect(SlotAlive, this);
            m_Player = com.GameInterface.Game.Character.GetClientCharacter();
            if (m_Player != null) SlotAlive();
        } catch (e:Object) {}
    }
    
    public function OnModuleActivated(archive:Object):Void {
        config = archive;
        if (config) {
            var i:Number = 0;
            while (i < grids.length) {
                var gx:Object = config.FindEntry("g" + i + "_x");
                var gy:Object = config.FindEntry("g" + i + "_y");
                if (gx !== undefined && gy !== undefined) {
                    grids[i].mc._x = Number(gx);
                    grids[i].mc._y = Number(gy);
                }
                i++;
            }
            var cp:Object = config.FindEntry("console_pin");
            if (cp !== undefined) consolePinned = (cp == 1);
            var clp:Object = config.FindEntry("log_p");
            if (clp !== undefined) console.logPlayerEnabled = (clp == 1);
            var clt:Object = config.FindEntry("log_t");
            if (clt !== undefined) console.logTargetEnabled = (clt == 1);
            if (consolePinned) console.createConsole();
        }
    }
    
    public function OnModuleDeactivated():Object {
        if (config) {
            var i:Number = 0;
            while (i < grids.length) {
                config.ReplaceEntry("g" + i + "_x", grids[i].mc._x);
                config.ReplaceEntry("g" + i + "_y", grids[i].mc._y);
                i++;
            }
            config.ReplaceEntry("console_pin", consolePinned ? 1 : 0);
            config.ReplaceEntry("log_p", console.logPlayerEnabled ? 1 : 0);
            config.ReplaceEntry("log_t", console.logTargetEnabled ? 1 : 0);
        }
        cleanup();
        try { com.GameInterface.Game.CharacterBase.SignalClientCharacterAlive.Disconnect(SlotAlive, this); } catch (e:Object) {}
        if (m_Player != null) { disconnectP(m_Player); m_Player = null; }
        if (m_Target != null) { disconnectT(m_Target); m_Target = null; }
        return config;
    }
'''
